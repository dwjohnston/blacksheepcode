---
meta:
  title: No, React Context is not causing too many renders
  description: A lot of people are under the impression that context shouldn't be used to store state, because it'll cause the entire application tree to re-render. This is a misnomer. 
  dateCreated: 2025-05-08
---
import { DemoFrame } from "@/components/DemoFrame/DemoFrame";
import { ReactRenders1, ReactRenders2, ReactRenders3, ReactRenders4, } from "@/demos/react-renders"
import { GithubPermalinkRsc } from "react-github-permalink/dist/rsc";

I commonly see people having the belief that React Context is not appropriate for managing state, because every time its state changes, it'll cause everything under the React provider to re-render. 

This is causes people to avoid using Context, and jumping straight to tools like Redux or Zustand.

It is a misnomer, and I'm here to disprove it. 

Here's my application. 

<details>
<summary>
  ### Top level of the application
</summary>
<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders.tsx#L26-L48"/>

I do have a button at the top of the application that _will_ re-render the whole application. 

This is to demonstrate that there is no trickery here. 
</details>
<details>
<summary>
  ### Context provider 
</summary>

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders.tsx#L18-L23"/>

My context provider is simple. We store state in a `useState` hook, and provide it via the context provider. 
</details>
<details>
<summary>
    ### Context consumers
</summary>

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders.tsx#L51-L68"/>

I have two components, both of them use this context. 
</details>
<details>
<summary>
  ### Unrelated component
</summary>

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders.tsx#L70-L75"/>

I have several instances of an unrelated component that doesn't use the context. 
</details>
<details>
<summary>
  ### Render tracking component
</summary>

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/common.tsx#L2-L13"/>

My render tracking component displays the dot in a different spot each time it renders.
</details>

What's the result? 

You can see for yourself: 

<DemoFrame
  description = {<>
  <p>Observe that clicking 'render all' button will in fact cause a render of the entire application.</p>
  <p>Observe that clicking the 'Change state' button, only affect the components consuming the context.</p>
  </>}
>
  <ReactRenders1/>
</DemoFrame>

## Where does this confusion come from? 

I think this confusion comes from two things. 

### 1. You really shouldn't bung all your state into one provider. 

Were I to add color/setColor, foo/setFoo and bar/setBar pairs to the same context provider, and had a new component FooComponent, using those new parts of state, these state changes _will_ cause re-renders. All the consumers of the one context provider will re-render when state changes. 

<DemoFrame
  description = {<>
  <p>Observe that randomizing the color causes renders of the other context consumers.</p>
  </>}
>
  <details>
  <summary>Code</summary>
  <GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders2.tsx#L83-L95"/>
  </details>
  <ReactRenders2/>
</DemoFrame>

This is fine if it's all related data and they needed to show the change anyway. 

But if you have two sets of unrelated data, then you can just use two context providers!

### \{children\} don't cause renders

I think a lot of the confusion comes from knowing that the render of a component will cause all of its descendants to render.

And because context providers usually live at the top of the application, people believe that the context provider, when it re-renders, will cause everything below it to render.

Unfortunately, the terminology is a bit confusing here!

Consider two seemingly similar components 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders3.tsx#L8-L35"/>

The first directly renders the RenderTracker. 

The second has it passed in via the `children` prop. 

The terminology is a bit ambiguous, in both cases these can be called 'children' in common parlance.  

However, they behave a lot differently!

<DemoFrame
  description = {<>
  <p>Observe that the RenderTracker that is passed in as a child does not re-render when the state changes.</p>
  </>}
>
  <ReactRenders3/>
</DemoFrame>


## Conclusions 

React context is not the performance boogeyman that it often made out to be. 

This common misconception has people reaching for tools like Redux and Zustand when it's really not needed.

Yes, if you load up dozens of bits of state into one context provider, then you're going to have problems. 

But to just pass state between components that are in different parts of your application, it's absolutely fine, and dare I say - it's much tidier solution using a global state provider like Redux of Zustand. 

If you really want a performance boogeyman, it's controlled components. 

For example here - we can see every keystroke causes a render: 

<DemoFrame
  description = {<>
  <p>Type in the text box and note a render on every keystroke.</p>
  </>}
>
    <details>
  <summary>Code</summary>
<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/302c939f42fdcab72d2c47a14d2759ebc1b6f0d4/src/demos/react-renders/ReactRenders4.tsx#L9-L17"/>

  </details>
  <ReactRenders4/>
</DemoFrame>

Don't be afraid of context providers. It's often the perfect tool for the job. 