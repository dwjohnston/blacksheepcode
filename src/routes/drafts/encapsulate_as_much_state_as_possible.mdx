---
meta:
  title: Encapsulate as much state as possible in your component
  description: A common pattern I see is a passing every bit of a component's state in as a prop. This just puts the responsibility of that component's actual useful logic on to the parent. 
  dateCreated: 2025-09-08
---
import { GithubPermalinkRsc } from "react-github-permalink/dist/rsc";
import { EncapsulateStateDemo } from "@/demos/encapsulate-state/Demo";
import { DemoFrame } from "@/components/DemoFrame/DemoFrame";


Let's say we have a nice simple component like this: 

<DemoFrame description={<p>Click the button to see it transition from pending to loading to success.</p>}>
  <EncapsulateStateDemo/>
</DemoFrame>



You click the button, it transitions to a loading state, then it transitions to either a success or error state. 

What I commonly see, is the component will be implemented with a interface like this: 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/08b640dfa990175a91c9471352724eb8176593c4/src/lib/SpecialButton/SpecialButton.tsx#L4-L7"/>

<details>
<summary>Implementation</summary>

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/6e86372808d2771b8a6d13d8b70c68efc7fc7b56/src/lib/SpecialButton/SpecialButton.tsx#L9-L16"/>
</details>

Whereby every bit of state that component could be in, is controlled by the parent and passed in as props.

## Interfaces like this are a mistake

There's a sense that components with an interface like this would be easy to test, we could write something like: 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/08b640dfa990175a91c9471352724eb8176593c4/src/lib/SpecialButton/SpecialButton.test.tsx#L7-L34"/>

It might be desirable to to write examples like this for Storybook, where we _just_ want to see the component as it is loading. 

But these tests do not test one of the key aspects of what we are interested in here - the state transitions. 

If we did want to test the state transitions, we could do it one of two ways: 

### 1. Create a wrapper component to contain the state in 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/08b640dfa990175a91c9471352724eb8176593c4/src/lib/SpecialButton/SpecialButton.test.tsx#L96-L127"/>

Here, we are getting a good demonstration of 'tests are test of how usuable your code is' - that we're having to create a bit of external state and manage its transitions in the test, is _also what every consumer of our component is going to have to do_. 

### 2. Change the props via `rerender`

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/6fe3dbbf3dba880579edf74541386e67fa3693c2/src/lib/SpecialButton/SpecialButton.test.tsx#L129-L156"/>

This is no test at all. We're simply stipulating that the props changed accurately, there's no gurantee that our parent component will infact make this change correctly. 

What this kind of interface really does, is it _makes the parent responsible for the logic of the state transition_ from pending to loading to error/success.  

Remember, the above example is a _very simple_ component. Imagine something like an Autocomplete component, which might contain state like what text the user has entered, is it loading, are there results, and so forth. 


## The better interface - one that encapsulates the state transitions internally. 

If instead we create an interface like this: 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/6fe3dbbf3dba880579edf74541386e67fa3693c2/src/lib/SpecialButton/SpecialButton2.tsx#L5-L7"/>

<details>
<summary>Implementation</summary>

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/c703f4fd15558d863c1a051d23c96d252f6a51fc/src/demos/encapsulate-state/SpecialButton2.tsx#L11-L30"/>
</details>

Now we can write our tests like this:

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/82a777fe054272e69432cfb0efc1296c961a4099/src/lib/SpecialButton/SpecialButton2.test.tsx#L7-L39"/>

This is much nicer!

Our test now resembles how we're going to use the component in practise, and it's very straight forward what's happening. 

## There's nothing say that you couldn't do both

Technically what we could do is do something like expose these components with less functionality as `SpecialButtonStateless` and then use this component in our `SpecialButton` component that then provides the the functionality. 

I think this would be of limited use - but might be helpful in a larger team with a dedicated design system, and wanting to see the component state statically. 
I would argue that the functioning `SpecialButton` component that is the important for actually building the application.  

## Why is this pattern so common? 

I suspect a big part of the reason that this pattern is so prevalent, is because of tools like Tanstack Query, which provide an interface that, to simplify, looks like this: 

```typescript
type LoadingResult<T> = {
  data: T; 
  state: "success"
}| {
  data: null;
  state: "pending" | "error" | "loading" 
}
```

that is, they're not providing async functions as their primary means of interface. 

When developers see that their means for fetching data looks like this, then they're going to tend to reproduce that interface onto the components they're creating. 

RTKQ does helpfully provide a [useLazyQuery](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#uselazyquery) hook which lends itself more to the style that I've advocate. 

You can see [this discussion on TanStack's Github](https://github.com/TanStack/query/discussions/1205) the basic answer to why a lazy/imperative function is not provided, is because it would be trivial for someone to implement themselves.

Here is how we extract such a lazy query from TanStack - it really is not well advertised: 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/82a777fe054272e69432cfb0efc1296c961a4099/src/components/Demo.tsx#L55-L60"/>

We use TanStack Query's [`queryClient.ensureQueryData`](https://tanstack.com/query/v4/docs/reference/QueryClient#queryclientensurequerydata) which is essentially a lazy query that will return the data if it already cached.  



## This isn't an argument against state management tools like TanStack Query

This isn't at all to say that tools like Tanstack are bad. Tools like Tanstack are very useful in that they provide query deduplication and caching.

However, async functions as a particular example, are often the right abstraction to represent 'user does a thing, it loads for a bit, and then the state changes'. 


