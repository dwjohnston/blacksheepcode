---
meta:
  title: Encapsulate as much state as possible in your component
  description: A common pattern I see is a passing every bit of a component's state in as a prop. This just puts the responsibility of that component's actual useful logic on to the parent. 
  dateCreated: 2025-09-08
---
import { GithubPermalinkRsc } from "react-github-permalink/dist/rsc";
import { SpecialButton2 } from "@/demos/encapsulate-state/SpecialButton2";
import { DemoFrame } from "@/components/DemoFrame/DemoFrame";


Let's say we have a nice simple component like this: 

<DemoFrame description="A button component with different states - try clicking it to see state transitions">
  <SpecialButton2 onClick={async () => {
    await new Promise((res) => setTimeout(res, 1000))
    return {success: true}
  }} state="pending" />
</DemoFrame>


You click the button, it transitions to a loading state, then it transitions to either a success or error state. 

What I commonly see, is the component will be implemented with a interface like this: 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/example-react-autocomplete/blob/ade0ca08dd8883c372ae7c11bd76133c8841aae9/src/lib/Autocomplete_A/Autocomplete.tsx#L4-L17"/>

Whereby every bit of state that component could be in, is controlled by the parent and passed in as props.

## Interfaces like this are a mistake

There's a sense that components with an interface like this would be easy to test, we could write something like: 

It might be desirable to to write examples like this for Storybook, where we _just_ want to see the component as it is loading. 

But these tests do not test one of the key aspects of what we are interested in here - the state transitions. 

If we did want to test the state transitions, we could do it one of two ways: 

### 1. Create a wrapper component to contain the state in 

Here, we are getting a good demonstration of 'tests are test of how usuable your code is' - that we're having to create a bit of external state and manage its transitions in the test, is _also_ what every consumer of our component is going to have to do. 

### 2. Change the props via `rerender`


This is no test at all. We're simply stipulating that the props changed accurately, there's no gurantee that our parent component will infact make this change correctly. 

What this kind of interface really does, is it makes the _parent_ responsible for the logic of the state transition from pending to loading to error/success.  


## The better interface - one that encapsulates the state transitions internally. 



Now we can write our tests like this:


This is much nicer!


## There's nothing say that you couldn't do both

Technically what we could do is do something like expose these components with less functionality as `SpecialButtonStateless` and then use this component in our `SpecialButton` component that then provides the the functionality. 

I'm not sure how much value this would actually have, and I argue that it's the functioning `SpecialButton` component that is the important one.  

## Why is this pattern so common? 

I suspect a big part of the reason that this pattern is so prevalent, is because of tools like Tanstack Query, which provide an interface that, to simplify, looks like this: 

```typescript
type LoadingResult<T> = {
  data: T; 
  state: "success"
}| {
  data: null;
  state: "pending" | "error" | "loading" 
}
```

that is, they're not providing async functions as their primary means of interface. 

When developers see that their means for fetching data looks like this, then they're going to tend to reproduce that interface onto the components they're creating. 

RTKQ does helpfully provide a [useLazyQuery](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#uselazyquery) hook which lends itself more to the style that I've advocate. 

You can see [this discussion on TanStack's Github](https://github.com/TanStack/query/discussions/1205) the basic answer to why a lazy/imperative function is not provided, is because it would be trivial for someone to implement themselves.

Here is how we extract such a lazy query from TanStack - it really is not well advertised: 


## This isn't an argument against state management tools like TanStack Query

This isn't at all to say that tools like Tanstack are bad. Tools like Tanstack are very useful in that they provide query deduplication and caching.

But async interfaces, in my opinion\


