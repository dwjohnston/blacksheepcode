---
meta:
  title: Let's talk about the behaviour of browser as it pertains to loading static assets - images, css and scripts. 
  description: I am the description
  dateCreated: 2024-11-19 12:00:00

series: 
  name: loading_optimisations
  part: 4

---

Let's turn to the behaviour of modules, and we talk 

## Module Scripts


### Imports resolve in serial 

Module scripts are a relatively new feature (supported by all major browsers since May 2018 according to [caniuse](https://caniuse.com/es6-module)). 

They allow us to write our code in maintainable separate files. 

One of the motivations of _bundling_ (compiling our separate files into one big file) is because we simply didn't have modules. 

Let's take this example: 

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        .dom-50kB {
            width: 200px;
            height: 200px; 
            overflow: hidden;
            display: inline-block;
            margin: 1em;
            border: dashed 1px black;
        }
    </style>

<script src="./script.js" type="module" ></script>



</head>
<body id="body">


</body>
</html>
```

```js
//script.js 

import {a} from "a.js"; 

a(): 

// 50kb filler
```

```js
//a.js 
import { b } from "./b.js";
export function a(){

    const div = document.createElement('div');; 
    div.textContent="I am A block";
    document.body.appendChild(div);

    b();
}

// 50kb filler
```

```js
//b.js

import {c} from './c.js';

export function b(){

    const div = document.createElement('div');; 
    div.textContent="I am B block";
    document.body.appendChild(div);

    c()
}

// 50kb filler

```

And so on for `c.js` and `d.js`

Let's observe the behaviour here. 

Note that the files load in serial until all the files are loaded, and _only then_ is the script evaluated. 

This makes sense - a JavaScript script can't be evaluated until the entire script is there, and then once it's there the first thing it encounters is an import statement, so evaluation pauses until that script is ready, but that script won't be ready until it evaluates its imports, and so forth. 

### A bundling example 

Note that the majority of the time was spent on the 'waiting for server response' portion of the waterfall. If we could reduce that to just one script download with all the content we need then we avoid that overhead.

This shows the second motivation for bundling - reducing the overhead of multiple server roundtrips. 

```js

//script.js


a();

export function a(){

    const div = document.createElement('div');; 
    div.textContent="I am A block";
    document.body.appendChild(div);

    b()
}

export function b(){

    const div = document.createElement('div');; 
    div.textContent="I am B block";
    document.body.appendChild(div);

    c()
}

export function c(){
    const div = document.createElement('div');; 

    div.textContent="I am C block";
    document.body.appendChild(div);

    d()
}

export function d(){

    const div = document.createElement('div');; 
    div.textContent="I am D block";
    document.body.appendChild(div);
}

// 4 * 50kB filler

```

In this scenario we still get essentially the same behaviour, we still have to download all of the JavaScript, and only then does our application execute.  The saving we made is that we don't have to wait for server response for each module. 


### But don't forget about caching!

The loading waterfalls are only really a problem if we need to return to the server to request the module. 

If the module is in the browser cache, _and_ the browser can trust that it's up to date, then the problems of having to return to the server are negated. 

Of course, for users hitting the website for the first time, they will still have that loading waterfall. This can be negated with preloading the modules. 

### Preloading modules 

We can preload our modules in similar fashion as the `rel="preload"` method mentioned in part 1. 

For modules we need to use [`rel="modulepreload"`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/modulepreload) which has support across major browsers since September 2023 according to [caniuse](https://caniuse.com/?search=modulepreload). 



### Cache invalidation cascades 

Let's say we have an application that looks like this: 

```
root.js -> a.js -> b.js -> c.js 
```

But we're using some kind of build tooling that adds file hashes to the file names, and we immutably cache the data assets. So our files really look like: 

```
root-1.js
a-1.js
b-1.js
c-1.js
d-1.js 
```

Now if we change some of the content of `root.js`, then our files will look like this: 

```diff
-root-1.js
+root-2.js
a-1.js
b-1.js
c-1.js
d-1.js 
```

Great, users that have already gone to our application only need to download the new `root-2.js`. 

But what if we change the content of `d.js`? The problem is that in default behaviour - the compiled file for `c.js` will need to update its import like:

```diff

-import {d} from "d-1.js"; 
+import {d} from "d-2.js"; 
```

and so its file hash will change, and then b will need to change its import, and so forth. An update of `d.js` will cause all of the files further up the dependency chain to also be invalidated. 

