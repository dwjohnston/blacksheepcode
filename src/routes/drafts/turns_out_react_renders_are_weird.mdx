---
meta:
  title: Turns out react renders are a bit weird 
  description: I am the description
  dateCreated: 2022-11-28
---

import { DemoFrame } from "@/components/DemoFrame/DemoFrame";
import { ReactRenders1, ReactRenders2, ReactRenders3, ReactRenders4, ReactRenders5 } from "@/demos/react-renders"
import { GithubPermalinkRsc, GithubIssueLinkRsc } from "react-github-permalink/dist/rsc";
import { InfoPanel } from "@/components/InfoPanel/InfoPanel"; 
import RenderTree from "@/assets/render_tree.png"
import Image from "next/image";


In a previous post I highlighted a highlighted the difference between two subtley different components - one that recieves its content via the a `children` prop, and the other that renders its content directly. 


<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/2fbbb700d23761ff460f4b41745eaee91fc7571c/src/demos/react-renders/ReactRenders3.tsx#L8-L39"/>

<DemoFrame
  description = {<>
  <p>Observe that the RenderTracker that is passed in as a child does not re-render when the state changes.</p>
  </>}
>
  <ReactRenders3/>
</DemoFrame>

At the time, I described this as an _ambiguity about what we call 'children'_ in React. 

However, if take a look at React's own [_Understanding Your UI as a tree_](https://react.dev/learn/understanding-your-ui-as-a-tree) documentation, we can see that they make no such distinction between children that are provided via the `props.children` prop and children that are directly rendered.

In their example they have this jsx:

```jsx
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
```

and this corresponding render tree diagram: 

<Image src={RenderTree} alt ="A tree diagram showing the InspirationGenerator node having two children - FancyText and Copyright"/>

They make no distiction between `FancyText` and `Copyright` even though one is directly rendered and the other is provided by `props.children`. 

See my issue querying why the difference in rendering behaviour is not mentioned here: 

<GithubIssueLink issueLink="https://github.com/reactjs/react.dev/issues/8007"/>

This kind of lines up with how I've conceptualised of what React is doing, where if I write some kind like this: 

```jsx
function Foo(){
  return <Bar text="hello world!"/>
}
```

it would be like me writing

```js
function Foo(){
  return Bar({text: "hello world!"})
}
```

_this isn't quite accurate_. 

Let's look at some actual compiled JSX: 

```jsx
export function ChildrenStyleOne() {
    return <div id="foo">
        <p>A regular node</p>
        <SomeThing text="world!" />
    </div>
}
``` 

compiles to: 

```js
function ChildrenStyleOne() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    id: "foo",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
        children: "A regular node",
      }),
      // Note `SomeThing` remains uncalled.  ðŸ‘‡ 
      /* @__PURE__ */ jsxRuntimeExports.jsx(SomeThing, { text: "world!" }),
    ],
  });
}
```

That is, the compiled function does not _call_ `SomeThing` it merely retains a reference to it and what is props will be. 


```tsx
export function ChildrenStyleTwo(props: React.PropsWithChildren) {
    return <div id="bar">
        <p>A regular node</p>
        {props.children}
    </div>
}
```

compiles to: 

```
function ChildrenStyleTwo(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    id: "bar",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
        children: "A regular node",
      }),
      // ðŸ‘‡ a straight reference to props.children
      props.children,
    ],
  });
}
```

This makes sense, rather than React resolving the entire UI tree a single event loop, it makes sense that the React engine 'takes a breath' between each UI node, and waits till the next event loop to resolves the next nodes. This way - resolving the UI tree is not one big thread blocking execution. 

At this point we've just got some compiled code - let's actually call this code: 

```jsx
function log(obj) {
  console.log(
    util.inspect(obj, {
      showHidden: false,
      depth: null,
      colors: true,
    })
  );
}

log(ChildrenStyleOne({}));
```

logs: 

```
{
  '$$typeof': Symbol(react.transitional.element),
  type: 'div',
  key: null,
  ref: null,
  props: {
    id: 'foo',
    children: [
      {
        '$$typeof': Symbol(react.transitional.element),
        type: 'p',
        key: null,
        ref: null,
        props: { children: 'A regular node' }
      },
      // ðŸ‘‡ this is the node we are interested in 
      {
        '$$typeof': Symbol(react.transitional.element),
        type: [Function: SomeThing],
        key: null,
        ref: null,
        props: { text: 'world!' }
      }
    ]
  }
}
```

We can see here we still haven't called `SomeThing` - we're still just maintaining a reference to the function and the props that will be passed to it. 

If log the `props.children` style function call: 

```js
log(
  ChildrenStyleTwo({
    children: jsxRuntimeExports.jsx(SomeThing, {}),
  })
);
```

We get: 

```
{
  '$$typeof': Symbol(react.transitional.element),
  type: 'div',
  key: null,
  ref: null,
  props: {
    id: 'foo',
    children: [
      {
        '$$typeof': Symbol(react.transitional.element),
        type: 'p',
        key: null,
        ref: null,
        props: { children: 'A regular node' }
      },
      // ðŸ‘‡ this is the node we are interested in 
      {
        '$$typeof': Symbol(react.transitional.element),
        type: [Function: SomeThing],
        key: null,
        ref: null,
        props: { text: 'world!' }
      }
    ]
  }
}
```

We get _the exact same looking structure_. 

## What gives? Where does the difference in rendering behaviour come from? 

Well, observe what happens if we call this code: 

```js
const childrenStyleOneProps = {};

const a = ChildrenStyleOne(childrenStyleOneProps);
const b = ChildrenStyleOne(childrenStyleOneProps);

console.log(a.props.children[1] === b.props.children[1]);
```

That is - we're asking, is this object: 

```
      {
        '$$typeof': Symbol(react.transitional.element),
        type: [Function: SomeThing],
        key: null,
        ref: null,
        props: { text: 'world!' }
      }
```

the same the first time we call it, vs the second time we call it? 

And the answer is: 

```
false
```

Whereas, in this case; 

```
const childrenStyleTwoProps = {
  children: jsxRuntimeExports.jsx(SomeThing, {}),
};

const c = ChildrenStyleTwo(childrenStyleTwoProps);
const d = ChildrenStyleTwo(childrenStyleTwoProps);

console.log(c.props.children[1] === d.props.children[1]);

```

the answer is

```
true
```

and _this_ is where the difference in rendering behaviour lays. 

Essentially, what's happening as I understand it - is that when a React component renders, it generates one of these tree node objects, and then steps over each object inside, and compares it with the one _from the previous render_. 

If they are shallowly equal (i.e. `===` equal), then React does not need to bother stepping into that node in order to resolve its sub tree. 

## With React 19/Compiler this might not matter anyway

The state of [Compiler](https://react.dev/learn/react-compiler) is it's an opt feature that is ready to use. 

Compiler will automatically memoise properties and components. 

I've updated my vite.config.js to allow incremental adoption of compiler: 

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/react-renders/blob/b91494bff90774073c10ba7a2a362d37c8d083ef/vite.config.ts#L6-L13"/>

And I add the `"use memo"` annotation to my component:

<GithubPermalinkRsc permalink="https://github.com/dwjohnston/react-renders/blob/b91494bff90774073c10ba7a2a362d37c8d083ef/vite.config.ts#L6-L13"/>







