---
meta:
  title: Turns out react renders are a bit weird 
  description: I am the description
  dateCreated: 2022-11-28
---

import { DemoFrame } from "@/components/DemoFrame/DemoFrame";
import { ReactRenders1, ReactRenders2, ReactRenders3, ReactRenders4, ReactRenders5 } from "@/demos/react-renders"
import { GithubPermalinkRsc } from "react-github-permalink/dist/rsc";
import { InfoPanel } from "@/components/InfoPanel/InfoPanel"; 


In a previous post I highlighted a highlighted the difference between two subtley different components - one that recieves its content via the a `children` prop, and the other that renders its content directly. 


<GithubPermalinkRsc permalink="https://github.com/dwjohnston/blacksheepcode/blob/2fbbb700d23761ff460f4b41745eaee91fc7571c/src/demos/react-renders/ReactRenders3.tsx#L8-L39"/>

<DemoFrame
  description = {<>
  <p>Observe that the RenderTracker that is passed in as a child does not re-render when the state changes.</p>
  </>}
>
  <ReactRenders3/>
</DemoFrame>

At the time, the way I conceptualised it, is that it would be a bit like writing some code like this: 

```js


function main(value){
    console.log(`the value is ${value}`);
}


function a(){
    return 'abcdefg';
}

main(a());

```

That is - the value is already calculated by the time the function `main` executes. 

This is in contrast to some code like this: 

```js
function main(){
    console.log(`the value is ${a()}`);
}


function a(){
    return 'abcdefg';
}

main();
```

Where `a` executes as a _part_ of the execution of `main`. 


But I have a counterpoint that demonstrates that this isn't what is happening. 

<DemoFrame
  description = {<>
  <p>Observe that in both cases the render tracker remounts when it moves</p>
  </>}
>
  <ReactRenders5/>
</DemoFrame>


If it were true that, in the first style, the actual rendering of the component was done outside of the component - then what we would see here is the component would change position without remounting and without rerendering. 

But that's not what we see. 

## So what is going on here? 

The way I've taken to understanding this is to just look at what's happening in the compilation and run steps. 

So what I've done is I've created a simple vite project and we can inspect what happens. 


```jsx
import  { type PropsWithChildren } from "react";

function Inner() {
    return <span>Hello world!</span>
}

function A(props: PropsWithChildren<object>){
    return <div>
        {props.children}
    </div>
}


function B(){
    return <div>
        <Inner/>
    </div>
}


function Main(){
    return <div className="foo" onClick={() =>{}}>
        <A><Inner/></A>
        <B/>
    </div>
}

export default Main
```

Here's what we get: 

```js
import { j as jsxRuntimeExports } from "../_virtual/jsx-runtime-CocFHxF7.js";
import "../_virtual/index-BAGgfTGQ.js";
function Inner() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Hello world!" });
}
function A(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children });
}
function B() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Inner, {}) });
}
function Main() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "foo", onClick: () => {
  }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(A, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Inner, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(B, {})
  ] });
}
export {
  Main as default
};
```

Now of course, at this point we haven't actually executed any code - JSX is just short hand for this. 

So what happens if we actually call this code? 

```js
console.log(
  util.inspect(Main(), { showHidden: false, depth: null, colors: true })
);
```

Well, we get this: 

```
{
  '$$typeof': Symbol(react.transitional.element),
  type: 'div',
  key: null,
  ref: null,
  props: {
    className: 'foo',
    onClick: [Function: onClick],
    children: [
      {
        '$$typeof': Symbol(react.transitional.element),
        type: [Function: A],  // ðŸ‘ˆthe function remains uncalled!
        key: null,
        ref: null,
        props: {
          children: {
            '$$typeof': Symbol(react.transitional.element),
            type: [Function: Inner], // ðŸ‘ˆthe function remains uncalled!
            key: null,
            ref: null,
            props: {}
          }
        }
      },
      {
        '$$typeof': Symbol(react.transitional.element),
        type: [Function: B], // ðŸ‘ˆthe function remains uncalled!
        key: null,
        ref: null,
        props: {}
      }
    ]
  }
}
```

This highlights the important part - 

_when the function is is eventually called - it does not call all of the sub-components_. 

It _just_ declares what the children are -


To take my initial, it's more akin to doing something like this: 

```js
function main(value){
    return {
        headline: "hello", 
        content: value,
    }
}


function a(){
    return 'abc'
}

main(a());
```


```js
function main(){
    return {
        headline: "hello", 
        content: a(),
    }
}


function a(){
    return 'abc'
}

main();
```

```js


function main(value){
    return {
        headline: "hello", 
        content: value,
    }
}


function a(){
    return 'abc'
}

main(a); //A is uncalled
```


```js


function main(value){
    return {
        headline: "hello", 
        content: a,
    }
}


function a(){
    return 'abc'
}

main(); //A is uncalled
```


But note that in this paradigm  - both of these still end up returning the same result. \



## Why remounts when the component moves? 

This is an straight forward one to answer -

https://react.dev/learn/preserving-and-resetting-state

Essentially because in React's model of the world, a component  in the render tree is only considered 'the same component' if it occupies the exact same place in the render tree. 

When we move the component react treats this as a new component. 


## So why _is_ there an optimisation when we pass a component as children? 

I'm stumped for an answer right now - it must be some kind of optimisation they make.
