---
meta:
  title: Reasons to not use GraphQL
  description: GraphQL is one of the cool kids in modern web development - but I generally recommend against using it. 
  dateCreated: 2025-06-30
---

In this post I'm going to make the case _against_ GraphQL, but first, let's make the case for it. 

## The case for GraphQL

### GraphQL reduces loading waterfalls

A RESTful scenario (one I've been before!) that can be solved with GraphQL looks like this: 

- The user navigates to their todos page, and this requests `GET /todos`. 
- Once the todo's have been fetched, we inspect the `todo.projectGroupID` and we fetch the relvant project groups with `GET /groups/{groupId}`. 
- Once the individual project groups have been fetched, we inspect them to get the `projectGroup.groupLeaderUserId` and we fetch the leaders of each group with `GET /users/{userId}`. 

This causes a serial loading waterfall, meaning that realistically the page might not ready for a full second. 

GraphQL solves this problem by having that serial loading waterfall happen on the backend - hopefully right next to the database. 

The serial loading waterfall still exists, it'll just occur faster. 

**Counterpoint:** This loading waterfall can also be solved with server side rendering. 

### GraphQL allows consumers to quickly build out bespoke functionality by writing their own GraphQL queries

The idea is, once the GraphQL API exists, consumers of it don't need to wait for the API maintainers to create new endpoints, they can just write the single graphql query that has all the data they need. 

This is actually a dishonest characterisation of the advantage - the GraphQL API still needs to implemented such that all the data required is available. The consumer could similarly write a series of RESTful requests that provides the data they will need. 

That said, I'll admit that writing a series of joining joining logics is a lot easier with GraphQL, particularly with Apollo's GraphQL sandbox.

### GraphQL abstracts the details of a multitude of upstreams

Enterprises appear to be attracted to GraphQL because they have a situation where they have a multitude of upstream services, each with slightly different conventions, and so a backend-for-frontend can serve as a mechanism for hiding the uglyness and providing a coherent experience to ultimate consumer of the APIs. 

While a BFF can be helpful here, it doesn't need to be a _GraphQL_ one. A RESTful one might suffice.

## The case against GraphQL

### You're losing a wealth of existing tooling developed for REST APIs

In the desire to reduce serial waterfalls you're throwing the baby out of with the bath water by adopting GraphQL - there's a lot of tooling you get with a REST API that you'll lose. 

#### HTTP Caching Semantics

GraphQL funnels all requests through usually a `POST /graphql` endpoint. 

This means conventional HTTP caching semantics do not work, which rely on caching on a per URL basis. 

Instead, caching needs to be achived with implementation specific solutions - such as Apollo's [cache directives](https://www.apollographql.com/blog/caching-graphql-results-in-your-cdnhttps://www.apollographql.com/blog/caching-graphql-results-in-your-cdn).

HTTP Cache headers on the other hand, are old hat in the internet, and work automatically in a variety of tools, include the browser, cache tools like Varnish and various CDNs.

In order to take advantage of HTTP caching semantics, the server just needs to add the cache headers and the variety of tools will just work with them. 

GraphQL on the otherhand is not nearly so universally supported, and it's likely that you'll need to configure implementation specific mechanisms where ever you need the cache configuration to be respected. 

#### OpenAPI based tooling

There's a wealth of OpenAPI tooling, from code generation to documentation to mock generation. 

Granted there are GraphQL tools that also help with these things - the ecosystem for OpenAPI is much richer.  

#### Observability tooling

Traditional observability tools rely heavily on the API being RESTful - they're using URLs and headers to group the requests. 

Observability tools commonly don't inspect request and response _bodies_ that's Personally Identifiable Information. 

GraphQL though - puts what would otherwise be query parameters into the request body - meaning that some observability tools may lose track of it. 

Granted that many observability tools do now offer GraphQL compatability, these solutions will be less battle tested than their REST counterparts. 

### You will now need to deal with problems that are specific to GraphQL 

#### The n+1 problem

The [n+1 problem](https://hygraph.com/blog/graphql-n-1-problem) is an issue with GraphQL implementations where, in a naive implementation GraphQL can request exact same resource from an upstream, multiple times, for the same query. |

For example, if we have a list of todos, and we're fetching the projectGroups, many of the todos may have the same projectGroupId, and without adding a mitigation GraphQL ends up making the the same request multiple times. 

In fairness, this is not entirely unique to GraphQL. A RESTful BFF that attempted to reduce the serial loading waterfalls could encounter the same problem. 

#### Malicious query construction

With GraphQL it's possible for an attacker to create malicious queries that will cause your GraphQL server to grind to a halt. 

Such queries don't require resources by the attacker, like a conventional DOS attack would - the idea is the attacker can send a single query that causes a lot of work for the GraphQL server and its upstreams to then resolve.

One solution for this is [persisted queries](https://www.apollographql.com/docs/apollo-server/performance/apq).

Persisted queries are actually an optimisation to reduce bandwidth, by reducing the GraphQL query to just a content hash. But this can be used mitigate malicious queries as well, by allowing only a whitelist of query hashes to reach the GraphQL server. 

But note that this negates one of the core advantages of using GraphQL - the ability for consumers to build custom queries on the fly! 

By introducing query whitelisting any consumer now has a dependency on the team maintaining the query whitelist before their code is production ready. 

## Conclusions

If the reason you are considering GraphQL is because you think it's going to be _easier_ than REST, it's not. 

Consider what you'll be losing. 

If you have a lot of chained/dependent queries, then sure, GraphQL might be good for you. 

But if your application is a fairly straight forward CRUD style app - consider whether you're actually going to be making use of the features of GraphQL. 

