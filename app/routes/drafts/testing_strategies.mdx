# Testing strategies for SPAs involving state management. 

In my experience it is the presence of global state management that causes the most difficulty when it comes to testing React applications. 

## Tooling 

There are three kinds of environments that we might write tests:

- Jest/RTL/JSDOM 

- Storybook

- Cypress/Playwright
  - E2E tests against a deployed application
  - Component tests


## Some disparate caveats and philosophies


**1. Writing new code to be testable, and writing tests for an existing codebase with low test coverage are two completely different practices**

It's worth keeping in mind that if you're reading an article on 'here's how to write testable' code, as sound and useful as the advice might be, it may be only useful within the context of if you were creating a new project/new module. 

Writing tests for some existing, untested code, shouldn't involve (or in practise, should minimise) any 'we need to rewrite the code in order to test it'. 

An example of how this distinction might play out, is I would generally give the advice that you shouldn't rely on module mocking as your testing strategy, and you should prefer dependency injection instead (more on this later). However, module mocking can be very a powerful tool in testing a codebase that hasn't implemented a dependency injection pattern. 


**2. Developers will copy what they already see in the codebase**

As a general philosophy for all software development, developers are going to continue with the patterns they already see in the codebase. Questions like 'how do I get this thing from state?' or 'How do I interact with this button in a test?' they'll look at what other code has done, and copy that, and continue to copy that as long as it is being effective in getting their job done. 


**3. It's easier to write tests if the existing test infrastructure is already set up**. 

Some testing strategies (eg. using MSW) may involve creating large amounts of boilerplate and/or test data, and once this is done writing tests might be somewhat easy. 

But in an untested codebase, creating this large amount of test data and boilerplate maybe an unpalatable and daunting proposition. 

**4. We're talking about a REST API here**

Some of the problems I'll mentioned may be solved with GraphQL. However let's just assume that we have a REST API and we're not about change that. 

**5. The industry needs to do a better job writing documentation for how to write tests for code using their frameworks.**

TanStack [does have a dedicated testing section in their docs](https://tanstack.com/query/latest/docs/react/guides/testing). [Permalink](https://web.archive.org/web/20230926233441/https://tanstack.com/query/latest/docs/react/guides/testing). 


## The application we are testing

Let's take an application like Github. For the purposes of this exercise, let's ignore all of the git operations involved, which is not something I have given much thought to, and we'll assume that it's otherwise a CRUD app.

When we create an issue or view, here are some of the user interactions available to us. 

- When creating an issue there is a title and body textfield to be filled
- The body textfield needs to respond to keyboard shortcuts
- The body textfield needs to respond to pasting files/images in
- In the body textfield if we type `#` it gives us a selector to select other issues/pull requests
- In the body textfield if we type `@` it gives us a selector to select users.
- On the right hand panel we can assign users, projects, labels etc. 

Clearly a non-trivial application, and that kind of thing that we really do want some automated tests on. 

## How the state management tools suggest you test

The state management library commonly recommend using MSW to Mock API calls, and state that you should include the logic of your state management layer within the unit under test. 

See: 

- [TK Dodo's Blog](https://tkdodo.eu/blog/testing-react-query)  (Permalink)(https://web.archive.org/web/20230926234138/https://tkdodo.eu/blog/testing-react-query)

- [Redux docs](https://redux.js.org/usage/writing-tests) 

>Prefer writing integration tests with everything working together. For a React app using Redux, render a <Provider> with a real store instance wrapping the components being tested. Interactions with the page being tested should use real Redux logic, with API calls mocked out so app code doesn't have to change, and assert that the UI is updated appropriately.

>Do not try to mock selector functions or the React-Redux hooks! Mocking imports from libraries is fragile, and doesn't give you confidence that your actual app code is working.

To be clear - I think the reasoning here is sound - often what we want when it comes to testing, isn't just 'when this data exists' - we also want to see the behaviour while the data is loading, etc. 

So here's how this might look: 

(Image)

And with MSW mocking

(Image)

## One improvement/amendment - MSW not necessary - Service injection instead

One thing I might suggest, is that instead of using MSW to mock API endpoints, we use service functions that we provide via what I call a service injection pattern. 

ie. instead of something like: 

```typescript 
//services/users.ts
async function getUsers() {
    // But actually, we have more logic here re: authentication refresh, headers etc
    return fetch('/users'); 
}


// serviceHooks/users.ts
import {getUsers} from "services/users";
function useUsers() {
    return useQuery({
        queryKeys: ['users'], 
        queryFn: async () => {
            const result = await getUsers(); 
            return result; 
        }
    })
}

```

We do this: 


```typescript 
//services/users.ts

// Untouched 
async function getUsers() {
    return fetch('/users'); 
}


// serviceHooks/users.ts
function useUsers() {
    // Rather than importing getUsers directly 
    // We get it from context
    const {getUsers} = useServices(); 
    return useQuery({
        queryKeys: ['users'], 
        queryFn: async () => {
            const result = await getUsers(); 
            return result; 
        }
    })
}

// providers/ServiceProvider 
import React, { PropsWithChildren } from "react";
import * as allServices from "../services/index";

export type AllServices = typeof allServices;

// Default behaviour is that each of the services just throw an error
const DEFAULT_SERVICES = Object.keys(allServices).reduce((acc, cur) => {
    acc[cur as keyof AllServices] = () => {
        throw new Error(`${cur} service not provided`)
    }
    return acc;
}, {} as AllServices)

const ServiceProviderContext = React.createContext(DEFAULT_SERVICES);

/**
 * We can choose to instantiate the services with our own overrides, for testing
 */
export function ServiceProvider(props: PropsWithChildren<Partial<AllServices>>) {
    const { children, ...rest } = props;
    return <ServiceProviderContext.Provider value={{
        ...allServices,
        ...rest
    }}>
        {props.children}
    </ServiceProviderContext.Provider>
}
export const useServices = () => {
    return React.useContext(ServiceProviderContext);
};

// App.tsx
import * as allServices from "../services/index";

export function App() {
    // In production we use the real services
    return <ServiceProvider {...allServices}>
        <RestOfTheApp/>
    </ServiceProvider>
}

```


And then we'd have a test like: 

```typescript
describe("Some Component", () => {
    it("Happy path", () => {
        render(<ServiceProvider getUsers={async () => {
            return [ 
                {
                    userId: "1", 
                    name: "Fooby"
                }
            ]   
        }}>
            <SomeComponent/>
        </ServiceProvider>);
    })
})
```






